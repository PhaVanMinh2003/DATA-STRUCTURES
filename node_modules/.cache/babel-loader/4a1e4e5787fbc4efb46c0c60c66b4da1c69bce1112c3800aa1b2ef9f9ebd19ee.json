{"ast":null,"code":"var _jsxFileName = \"/Users/phamvanminh/Workspace/academy/CTDL/algorithms-graphs/src/components/DataStructure/Array/Array.jsx\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Array() {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container py-4\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"C\\u1EA5u tr\\xFAc d\\u1EEF li\\u1EC7u m\\u1EA3ng\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 7\n    }, this), \"  \", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 39\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"C\\xE1c n\\u1ED9i dung ch\\xEDnh trong C\\u1EA5u tr\\xFAc d\\u1EEF li\\u1EC7u n\\xE2ng cao\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 7,\n        columnNumber: 60\n      }, this), \"Suffix Array (M\\u1EA3ng h\\u1EADu t\\u1ED1):\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 8,\n        columnNumber: 28\n      }, this), \"M\\xF4 t\\u1EA3: M\\u1ED9t m\\u1EA3ng ch\\u1EE9a t\\u1EA5t c\\u1EA3 c\\xE1c h\\u1EADu t\\u1ED1 c\\u1EE7a m\\u1ED9t chu\\u1ED7i, \\u0111\\u01B0\\u1EE3c s\\u1EAFp x\\u1EBFp theo th\\u1EE9 t\\u1EF1 t\\u1EEB \\u0111i\\u1EC3n. \\u1EE8ng d\\u1EE5ng: T\\xECm ki\\u1EBFm chu\\u1ED7i con, so s\\xE1nh chu\\u1ED7i, n\\xE9n d\\u1EEF li\\u1EC7u, x\\u1EED l\\xFD v\\u0103n b\\u1EA3n (v\\xED d\\u1EE5: t\\xECm m\\u1EABu trong chu\\u1ED7i d\\xE0i). \\u0110\\u1ED9 ph\\u1EE9c t\\u1EA1p: X\\xE2y d\\u1EF1ng: O(n log n) ho\\u1EB7c O(n) v\\u1EDBi c\\xE1c thu\\u1EADt to\\xE1n t\\u1ED1i \\u01B0u (nh\\u01B0 DC3/Skew). Truy v\\u1EA5n: O(log n) v\\u1EDBi t\\xECm ki\\u1EBFm nh\\u1ECB ph\\xE2n. V\\xED d\\u1EE5: T\\xECm t\\u1EA5t c\\u1EA3 c\\xE1c v\\u1ECB tr\\xED c\\u1EE7a m\\u1ED9t m\\u1EABu trong v\\u0103n b\\u1EA3n. KMP (Knuth-Morris-Pratt Algorithm): M\\xF4 t\\u1EA3: Thu\\u1EADt to\\xE1n t\\xECm ki\\u1EBFm chu\\u1ED7i con d\\u1EF1a tr\\xEAn vi\\u1EC7c s\\u1EED d\\u1EE5ng b\\u1EA3ng \\\"prefix function\\\" \\u0111\\u1EC3 tr\\xE1nh ki\\u1EC3m tra l\\u1EA1i c\\xE1c k\\xFD t\\u1EF1 \\u0111\\xE3 kh\\u1EDBp. \\u1EE8ng d\\u1EE5ng: T\\xECm ki\\u1EBFm m\\u1EABu trong chu\\u1ED7i, x\\u1EED l\\xFD v\\u0103n b\\u1EA3n. \\u0110\\u1ED9 ph\\u1EE9c t\\u1EA1p: X\\xE2y d\\u1EF1ng b\\u1EA3ng: O(m) (m l\\xE0 \\u0111\\u1ED9 d\\xE0i m\\u1EABu). T\\xECm ki\\u1EBFm: O(n + m) (n l\\xE0 \\u0111\\u1ED9 d\\xE0i v\\u0103n b\\u1EA3n). V\\xED d\\u1EE5: T\\xECm v\\u1ECB tr\\xED c\\u1EE7a m\\u1ED9t t\\u1EEB trong m\\u1ED9t \\u0111o\\u1EA1n v\\u0103n. Trie (C\\xE2y ti\\u1EC1n t\\u1ED1): M\\xF4 t\\u1EA3: M\\u1ED9t c\\xE2y d\\xF9ng \\u0111\\u1EC3 l\\u01B0u tr\\u1EEF t\\u1EADp h\\u1EE3p c\\xE1c chu\\u1ED7i, trong \\u0111\\xF3 m\\u1ED7i n\\xFAt \\u0111\\u1EA1i di\\u1EC7n cho m\\u1ED9t k\\xFD t\\u1EF1 c\\u1EE7a chu\\u1ED7i. \\u1EE8ng d\\u1EE5ng: T\\u1EF1 \\u0111\\u1ED9ng ho\\xE0n th\\xE0nh t\\u1EEB, ki\\u1EC3m tra ch\\xEDnh t\\u1EA3, t\\xECm ki\\u1EBFm t\\u1EEB \\u0111i\\u1EC3n, \\u0111\\u1ECBnh tuy\\u1EBFn IP. \\u0110\\u1ED9 ph\\u1EE9c t\\u1EA1p: Ch\\xE8n/t\\xECm ki\\u1EBFm: O(L) (L l\\xE0 \\u0111\\u1ED9 d\\xE0i chu\\u1ED7i trung b\\xECnh). B\\u1ED9 nh\\u1EDB: T\\u1ED1n b\\u1ED9 nh\\u1EDB h\\u01A1n so v\\u1EDBi c\\xE1c c\\u1EA5u tr\\xFAc kh\\xE1c. V\\xED d\\u1EE5: X\\xE2y d\\u1EF1ng t\\u1EEB \\u0111i\\u1EC3n t\\xECm ki\\u1EBFm nhanh. HLD (Heavy-Light Decomposition): M\\xF4 t\\u1EA3: Ph\\xE2n t\\xE1ch m\\u1ED9t c\\xE2y th\\xE0nh c\\xE1c chu\\u1ED7i \\\"n\\u1EB7ng\\\" v\\xE0 \\\"nh\\u1EB9\\\" \\u0111\\u1EC3 h\\u1ED7 tr\\u1EE3 truy v\\u1EA5n hi\\u1EC7u qu\\u1EA3 tr\\xEAn c\\xE2y. \\u1EE8ng d\\u1EE5ng: Truy v\\u1EA5n \\u0111\\u01B0\\u1EDDng \\u0111i tr\\xEAn c\\xE2y (v\\xED d\\u1EE5: t\\u1ED5ng tr\\u1ECDng s\\u1ED1, gi\\xE1 tr\\u1ECB l\\u1EDBn nh\\u1EA5t), c\\u1EADp nh\\u1EADt gi\\xE1 tr\\u1ECB tr\\xEAn c\\xE2y. \\u0110\\u1ED9 ph\\u1EE9c t\\u1EA1p: X\\xE2y d\\u1EF1ng: O(n). Truy v\\u1EA5n/c\\u1EADp nh\\u1EADt: O(log n). V\\xED d\\u1EE5: T\\xECm t\\u1ED5ng tr\\u1ECDng s\\u1ED1 tr\\xEAn \\u0111\\u01B0\\u1EDDng \\u0111i gi\\u1EEFa hai n\\xFAt trong c\\xE2y. Mo\\u2019s Algorithm (Thu\\u1EADt to\\xE1n Mo): M\\xF4 t\\u1EA3: M\\u1ED9t thu\\u1EADt to\\xE1n x\\u1EED l\\xFD c\\xE1c truy v\\u1EA5n ngo\\u1EA1i tuy\\u1EBFn tr\\xEAn m\\u1EA3ng b\\u1EB1ng c\\xE1ch s\\u1EAFp x\\u1EBFp truy v\\u1EA5n theo th\\u1EE9 t\\u1EF1 \\u0111\\u1EB7c bi\\u1EC7t \\u0111\\u1EC3 gi\\u1EA3m chi ph\\xED x\\u1EED l\\xFD. \\u1EE8ng d\\u1EE5ng: X\\u1EED l\\xFD c\\xE1c truy v\\u1EA5n tr\\xEAn \\u0111o\\u1EA1n (range queries), nh\\u01B0 t\\xEDnh t\\u1ED5ng, s\\u1ED1 ph\\u1EA7n t\\u1EED kh\\xE1c nhau trong m\\u1ED9t \\u0111o\\u1EA1n. \\u0110\\u1ED9 ph\\u1EE9c t\\u1EA1p: T\\u1ED5ng th\\u1EDDi gian: O(n\\u221An + q\\u221An) (n l\\xE0 k\\xEDch th\\u01B0\\u1EDBc m\\u1EA3ng, q l\\xE0 s\\u1ED1 truy v\\u1EA5n). V\\xED d\\u1EE5: \\u0110\\u1EBFm s\\u1ED1 ph\\u1EA7n t\\u1EED kh\\xE1c nhau trong c\\xE1c \\u0111o\\u1EA1n c\\u1EE7a m\\u1ED9t m\\u1EA3ng. C\\xE1c n\\u1ED9i dung b\\u1ED5 sung th\\u01B0\\u1EDDng g\\u1EB7p Ngo\\xE0i 5 n\\u1ED9i dung \\u0111\\u01B0\\u1EE3c li\\u1EC7t k\\xEA trong m\\xE3 c\\u1EE7a b\\u1EA1n, trong c\\xE1c kh\\xF3a h\\u1ECDc ho\\u1EB7c t\\xE0i li\\u1EC7u v\\u1EC1 c\\u1EA5u tr\\xFAc d\\u1EEF li\\u1EC7u n\\xE2ng cao, m\\u1ED9t s\\u1ED1 c\\u1EA5u tr\\xFAc/thu\\u1EADt to\\xE1n kh\\xE1c c\\u0169ng th\\u01B0\\u1EDDng \\u0111\\u01B0\\u1EE3c \\u0111\\u1EC1 c\\u1EADp: Segment Tree (C\\xE2y ph\\xE2n \\u0111o\\u1EA1n): M\\xF4 t\\u1EA3: C\\u1EA5u tr\\xFAc d\\u1EEF li\\u1EC7u d\\u1EA1ng c\\xE2y \\u0111\\u1EC3 x\\u1EED l\\xFD c\\xE1c truy v\\u1EA5n tr\\xEAn \\u0111o\\u1EA1n (range queries) v\\xE0 c\\u1EADp nh\\u1EADt gi\\xE1 tr\\u1ECB. \\u1EE8ng d\\u1EE5ng: T\\xEDnh t\\u1ED5ng, min, max tr\\xEAn \\u0111o\\u1EA1n, c\\u1EADp nh\\u1EADt gi\\xE1 tr\\u1ECB t\\u1EA1i m\\u1ED9t v\\u1ECB tr\\xED. \\u0110\\u1ED9 ph\\u1EE9c t\\u1EA1p: X\\xE2y d\\u1EF1ng: O(n). Truy v\\u1EA5n/c\\u1EADp nh\\u1EADt: O(log n). V\\xED d\\u1EE5: T\\xEDnh t\\u1ED5ng c\\xE1c ph\\u1EA7n t\\u1EED trong \\u0111o\\u1EA1n [l, r]. Fenwick Tree (C\\xE2y ch\\u1EC9 s\\u1ED1 nh\\u1ECB ph\\xE2n): M\\xF4 t\\u1EA3: M\\u1ED9t c\\u1EA5u tr\\xFAc d\\u1EEF li\\u1EC7u nh\\u1EB9 h\\u01A1n Segment Tree, d\\xF9ng \\u0111\\u1EC3 t\\xEDnh t\\u1ED5ng ti\\u1EC1n t\\u1ED1 ho\\u1EB7c c\\u1EADp nh\\u1EADt gi\\xE1 tr\\u1ECB. \\u1EE8ng d\\u1EE5ng: T\\xEDnh t\\u1ED5ng \\u0111o\\u1EA1n, \\u0111\\u1EBFm s\\u1ED1 l\\u1EA7n xu\\u1EA5t hi\\u1EC7n. \\u0110\\u1ED9 ph\\u1EE9c t\\u1EA1p: X\\xE2y d\\u1EF1ng: O(n log n). Truy v\\u1EA5n/c\\u1EADp nh\\u1EADt: O(log n). V\\xED d\\u1EE5: \\u0110\\u1EBFm s\\u1ED1 ph\\u1EA7n t\\u1EED nh\\u1ECF h\\u01A1n x trong m\\u1ED9t m\\u1EA3ng. Suffix Tree (C\\xE2y h\\u1EADu t\\u1ED1): M\\xF4 t\\u1EA3: M\\u1ED9t c\\xE2y n\\xE9n ch\\u1EE9a t\\u1EA5t c\\u1EA3 c\\xE1c h\\u1EADu t\\u1ED1 c\\u1EE7a m\\u1ED9t chu\\u1ED7i, t\\u1ED1i \\u01B0u h\\u01A1n Suffix Array v\\u1EC1 m\\u1EB7t truy v\\u1EA5n. \\u1EE8ng d\\u1EE5ng: T\\xECm ki\\u1EBFm chu\\u1ED7i, t\\xECm chu\\u1ED7i con d\\xE0i nh\\u1EA5t l\\u1EB7p l\\u1EA1i. \\u0110\\u1ED9 ph\\u1EE9c t\\u1EA1p: X\\xE2y d\\u1EF1ng: O(n) v\\u1EDBi thu\\u1EADt to\\xE1n Ukkonen. Truy v\\u1EA5n: O(m) (m l\\xE0 \\u0111\\u1ED9 d\\xE0i m\\u1EABu). V\\xED d\\u1EE5: T\\xECm chu\\u1ED7i con chung d\\xE0i nh\\u1EA5t gi\\u1EEFa hai chu\\u1ED7i. Persistent Data Structures (C\\u1EA5u tr\\xFAc d\\u1EEF li\\u1EC7u b\\u1EC1n v\\u1EEFng): M\\xF4 t\\u1EA3: L\\u01B0u tr\\u1EEF c\\xE1c phi\\xEAn b\\u1EA3n tr\\u01B0\\u1EDBc \\u0111\\xF3 c\\u1EE7a c\\u1EA5u tr\\xFAc d\\u1EEF li\\u1EC7u sau m\\u1ED7i thao t\\xE1c, cho ph\\xE9p truy v\\u1EA5n l\\u1ECBch s\\u1EED. \\u1EE8ng d\\u1EE5ng: Quay ng\\u01B0\\u1EE3c tr\\u1EA1ng th\\xE1i, truy v\\u1EA5n t\\u1EA1i m\\u1ED9t th\\u1EDDi \\u0111i\\u1EC3m trong qu\\xE1 kh\\u1EE9. V\\xED d\\u1EE5: Persistent Segment Tree \\u0111\\u1EC3 truy v\\u1EA5n t\\u1ED5ng \\u0111o\\u1EA1n t\\u1EA1i phi\\xEAn b\\u1EA3n tr\\u01B0\\u1EDBc. Treap (C\\xE2y nh\\u1ECB ph\\xE2n ng\\u1EABu nhi\\xEAn): M\\xF4 t\\u1EA3: K\\u1EBFt h\\u1EE3p gi\\u1EEFa c\\xE2y nh\\u1ECB ph\\xE2n t\\xECm ki\\u1EBFm v\\xE0 heap, s\\u1EED d\\u1EE5ng \\u01B0u ti\\xEAn ng\\u1EABu nhi\\xEAn \\u0111\\u1EC3 c\\xE2n b\\u1EB1ng c\\xE2y. \\u1EE8ng d\\u1EE5ng: Th\\xEAm, x\\xF3a, t\\xECm ki\\u1EBFm ph\\u1EA7n t\\u1EED v\\u1EDBi hi\\u1EC7u su\\u1EA5t trung b\\xECnh t\\u1ED1t. \\u0110\\u1ED9 ph\\u1EE9c t\\u1EA1p: Trung b\\xECnh: O(log n) cho c\\xE1c thao t\\xE1c. V\\xED d\\u1EE5: Qu\\u1EA3n l\\xFD t\\u1EADp h\\u1EE3p \\u0111\\u1ED9ng v\\u1EDBi c\\xE1c thao t\\xE1c ch\\xE8n/x\\xF3a. \\u1EE8ng d\\u1EE5ng th\\u1EF1c t\\u1EBF c\\u1EE7a C\\u1EA5u tr\\xFAc d\\u1EEF li\\u1EC7u n\\xE2ng cao X\\u1EED l\\xFD v\\u0103n b\\u1EA3n: Suffix Array, Suffix Tree, Trie, KMP \\u0111\\u01B0\\u1EE3c d\\xF9ng trong t\\xECm ki\\u1EBFm v\\u0103n b\\u1EA3n, n\\xE9n d\\u1EEF li\\u1EC7u, v\\xE0 ph\\xE2n t\\xEDch chu\\u1ED7i. H\\u1EC7 th\\u1ED1ng c\\u01A1 s\\u1EDF d\\u1EEF li\\u1EC7u: Segment Tree, Fenwick Tree h\\u1ED7 tr\\u1EE3 truy v\\u1EA5n nhanh tr\\xEAn d\\u1EEF li\\u1EC7u l\\u1EDBn. M\\u1EA1ng m\\xE1y t\\xEDnh: Trie d\\xF9ng trong \\u0111\\u1ECBnh tuy\\u1EBFn IP, HLD trong ph\\xE2n t\\xEDch m\\u1EA1ng. L\\u1EADp tr\\xECnh thi \\u0111\\u1EA5u: Mo\\u2019s Algorithm, HLD, Persistent Structures th\\u01B0\\u1EDDng \\u0111\\u01B0\\u1EE3c d\\xF9ng \\u0111\\u1EC3 gi\\u1EA3i c\\xE1c b\\xE0i to\\xE1n ph\\u1EE9c t\\u1EA1p trong ACM ICPC, Codeforces, v.v.\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 7,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 5,\n    columnNumber: 5\n  }, this);\n}\n_c = Array;\nexport default Array;\nvar _c;\n$RefreshReg$(_c, \"Array\");","map":{"version":3,"names":["Array","_jsxDEV","className","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/phamvanminh/Workspace/academy/CTDL/algorithms-graphs/src/components/DataStructure/Array/Array.jsx"],"sourcesContent":["\n\nfunction Array() {\n  return (\n    <div className=\"container py-4\">\n      <h2>Cấu trúc dữ liệu mảng</h2>  <br/>\n      <p>Các nội dung chính trong Cấu trúc dữ liệu nâng cao<br/>\nSuffix Array (Mảng hậu tố):<br/>\nMô tả: Một mảng chứa tất cả các hậu tố của một chuỗi, được sắp xếp theo thứ tự từ điển.\nỨng dụng: Tìm kiếm chuỗi con, so sánh chuỗi, nén dữ liệu, xử lý văn bản (ví dụ: tìm mẫu trong chuỗi dài).\nĐộ phức tạp:\nXây dựng: O(n log n) hoặc O(n) với các thuật toán tối ưu (như DC3/Skew).\nTruy vấn: O(log n) với tìm kiếm nhị phân.\nVí dụ: Tìm tất cả các vị trí của một mẫu trong văn bản.\nKMP (Knuth-Morris-Pratt Algorithm):\nMô tả: Thuật toán tìm kiếm chuỗi con dựa trên việc sử dụng bảng \"prefix function\" để tránh kiểm tra lại các ký tự đã khớp.\nỨng dụng: Tìm kiếm mẫu trong chuỗi, xử lý văn bản.\nĐộ phức tạp:\nXây dựng bảng: O(m) (m là độ dài mẫu).\nTìm kiếm: O(n + m) (n là độ dài văn bản).\nVí dụ: Tìm vị trí của một từ trong một đoạn văn.\nTrie (Cây tiền tố):\nMô tả: Một cây dùng để lưu trữ tập hợp các chuỗi, trong đó mỗi nút đại diện cho một ký tự của chuỗi.\nỨng dụng: Tự động hoàn thành từ, kiểm tra chính tả, tìm kiếm từ điển, định tuyến IP.\nĐộ phức tạp:\nChèn/tìm kiếm: O(L) (L là độ dài chuỗi trung bình).\nBộ nhớ: Tốn bộ nhớ hơn so với các cấu trúc khác.\nVí dụ: Xây dựng từ điển tìm kiếm nhanh.\nHLD (Heavy-Light Decomposition):\nMô tả: Phân tách một cây thành các chuỗi \"nặng\" và \"nhẹ\" để hỗ trợ truy vấn hiệu quả trên cây.\nỨng dụng: Truy vấn đường đi trên cây (ví dụ: tổng trọng số, giá trị lớn nhất), cập nhật giá trị trên cây.\nĐộ phức tạp:\nXây dựng: O(n).\nTruy vấn/cập nhật: O(log n).\nVí dụ: Tìm tổng trọng số trên đường đi giữa hai nút trong cây.\nMo’s Algorithm (Thuật toán Mo):\nMô tả: Một thuật toán xử lý các truy vấn ngoại tuyến trên mảng bằng cách sắp xếp truy vấn theo thứ tự đặc biệt để giảm chi phí xử lý.\nỨng dụng: Xử lý các truy vấn trên đoạn (range queries), như tính tổng, số phần tử khác nhau trong một đoạn.\nĐộ phức tạp:\nTổng thời gian: O(n√n + q√n) (n là kích thước mảng, q là số truy vấn).\nVí dụ: Đếm số phần tử khác nhau trong các đoạn của một mảng.\nCác nội dung bổ sung thường gặp\nNgoài 5 nội dung được liệt kê trong mã của bạn, trong các khóa học hoặc tài liệu về cấu trúc dữ liệu nâng cao, một số cấu trúc/thuật toán khác cũng thường được đề cập:\n\nSegment Tree (Cây phân đoạn):\nMô tả: Cấu trúc dữ liệu dạng cây để xử lý các truy vấn trên đoạn (range queries) và cập nhật giá trị.\nỨng dụng: Tính tổng, min, max trên đoạn, cập nhật giá trị tại một vị trí.\nĐộ phức tạp:\nXây dựng: O(n).\nTruy vấn/cập nhật: O(log n).\nVí dụ: Tính tổng các phần tử trong đoạn [l, r].\nFenwick Tree (Cây chỉ số nhị phân):\nMô tả: Một cấu trúc dữ liệu nhẹ hơn Segment Tree, dùng để tính tổng tiền tố hoặc cập nhật giá trị.\nỨng dụng: Tính tổng đoạn, đếm số lần xuất hiện.\nĐộ phức tạp:\nXây dựng: O(n log n).\nTruy vấn/cập nhật: O(log n).\nVí dụ: Đếm số phần tử nhỏ hơn x trong một mảng.\nSuffix Tree (Cây hậu tố):\nMô tả: Một cây nén chứa tất cả các hậu tố của một chuỗi, tối ưu hơn Suffix Array về mặt truy vấn.\nỨng dụng: Tìm kiếm chuỗi, tìm chuỗi con dài nhất lặp lại.\nĐộ phức tạp:\nXây dựng: O(n) với thuật toán Ukkonen.\nTruy vấn: O(m) (m là độ dài mẫu).\nVí dụ: Tìm chuỗi con chung dài nhất giữa hai chuỗi.\nPersistent Data Structures (Cấu trúc dữ liệu bền vững):\nMô tả: Lưu trữ các phiên bản trước đó của cấu trúc dữ liệu sau mỗi thao tác, cho phép truy vấn lịch sử.\nỨng dụng: Quay ngược trạng thái, truy vấn tại một thời điểm trong quá khứ.\nVí dụ: Persistent Segment Tree để truy vấn tổng đoạn tại phiên bản trước.\nTreap (Cây nhị phân ngẫu nhiên):\nMô tả: Kết hợp giữa cây nhị phân tìm kiếm và heap, sử dụng ưu tiên ngẫu nhiên để cân bằng cây.\nỨng dụng: Thêm, xóa, tìm kiếm phần tử với hiệu suất trung bình tốt.\nĐộ phức tạp:\nTrung bình: O(log n) cho các thao tác.\nVí dụ: Quản lý tập hợp động với các thao tác chèn/xóa.\nỨng dụng thực tế của Cấu trúc dữ liệu nâng cao\nXử lý văn bản: Suffix Array, Suffix Tree, Trie, KMP được dùng trong tìm kiếm văn bản, nén dữ liệu, và phân tích chuỗi.\nHệ thống cơ sở dữ liệu: Segment Tree, Fenwick Tree hỗ trợ truy vấn nhanh trên dữ liệu lớn.\nMạng máy tính: Trie dùng trong định tuyến IP, HLD trong phân tích mạng.\nLập trình thi đấu: Mo’s Algorithm, HLD, Persistent Structures thường được dùng để giải các bài toán phức tạp trong ACM ICPC, Codeforces, v.v.</p>\n    </div>\n  );\n}\n\nexport default Array;\n"],"mappings":";;AAEA,SAASA,KAAKA,CAAA,EAAG;EACf,oBACEC,OAAA;IAAKC,SAAS,EAAC,gBAAgB;IAAAC,QAAA,gBAC7BF,OAAA;MAAAE,QAAA,EAAI;IAAqB;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,MAAE,eAAAN,OAAA;MAAAG,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,eACrCN,OAAA;MAAAE,QAAA,GAAG,oFAAkD,eAAAF,OAAA;QAAAG,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAI,CAAC,8CACrC,eAAAN,OAAA;QAAAG,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAI,CAAC,22OAwE6G;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAG,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACxI,CAAC;AAEV;AAACC,EAAA,GAhFQR,KAAK;AAkFd,eAAeA,KAAK;AAAC,IAAAQ,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}